@model SagPoc.Web.Models.FieldMetadata
@using SagPoc.Web.Models

@{
    var componentType = Model.GetComponentType();
    var fieldId = $"field_{Model.CodiCamp}";
    var fieldName = Model.NomeCamp;
    var label = Model.LabeCamp;  // Não usa fallback - se LabeCamp é vazio, não exibe label
    var hasLabel = !string.IsNullOrEmpty(label);
    var isRequired = Model.IsRequired;
    var isDisabled = Model.IsDisabled;
    var hint = Model.HintCamp;

    // Calcular tamanho relativo baseado na largura do campo
    // Delphi usa ~340px de largura total, vamos mapear para colunas Bootstrap
    var width = Model.TamaCamp > 0 ? Model.TamaCamp : 150;
    var colClass = width switch
    {
        >= 300 => "col-12",        // Campo largo - linha inteira
        >= 200 => "col-md-8",      // Campo médio-grande
        >= 150 => "col-md-6",      // Campo médio
        >= 100 => "col-md-4",      // Campo pequeno
        _ => "col-md-3"            // Campo muito pequeno
    };

    // Checkboxes são menores
    if (componentType == ComponentType.Checkbox)
    {
        colClass = "col-md-6 col-lg-4";
    }
}

@switch (componentType)
{
    case ComponentType.Label:
        // LBL - Label estático
        <div class="@colClass mb-2">
            <span class="field-static-label" title="@hint">@label</span>
        </div>
        break;

    case ComponentType.TextInput:
        // E - Input de texto
        <div class="@colClass mb-3">
            @if (hasLabel)
            {
                <label for="@fieldId" class="form-label">
                    @label
                    @if (isRequired)
                    {
                        <span class="text-danger">*</span>
                    }
                </label>
            }
            <input type="text"
                   class="form-control"
                   id="@fieldId"
                   name="@fieldName"
                   title="@hint"
                   placeholder="@hint"
                   @(isRequired ? "required" : "")
                   @(isDisabled ? "disabled" : "")
                   data-mask="@Model.MascCamp" />
        </div>
        break;

    case ComponentType.NumberInput:
        // N - Input numérico
        <div class="@colClass mb-3">
            @if (hasLabel)
            {
                <label for="@fieldId" class="form-label">
                    @label
                    @if (isRequired)
                    {
                        <span class="text-danger">*</span>
                    }
                </label>
            }
            <input type="number"
                   class="form-control"
                   id="@fieldId"
                   name="@fieldName"
                   title="@hint"
                   placeholder="@hint"
                   @(Model.MiniCamp.HasValue ? $"min=\"{Model.MiniCamp}\"" : "")
                   @(Model.MaxiCamp.HasValue ? $"max=\"{Model.MaxiCamp}\"" : "")
                   step="@(Model.DeciCamp > 0 ? $"0.{"".PadRight(Model.DeciCamp - 1, '0')}1" : "1")"
                   @(isRequired ? "required" : "")
                   @(isDisabled ? "disabled" : "") />
        </div>
        break;

    case ComponentType.DateInput:
        // D - Input de data
        <div class="@colClass mb-3">
            @if (hasLabel)
            {
                <label for="@fieldId" class="form-label">
                    @label
                    @if (isRequired)
                    {
                        <span class="text-danger">*</span>
                    }
                </label>
            }
            <input type="date"
                   class="form-control"
                   id="@fieldId"
                   name="@fieldName"
                   title="@hint"
                   @(isRequired ? "required" : "")
                   @(isDisabled ? "disabled" : "") />
        </div>
        break;

    case ComponentType.Checkbox:
        // S - Checkbox
        // Hidden field garante que valor 0 é enviado quando checkbox não marcado
        // PadrCamp define se o checkbox começa marcado (1) ou desmarcado (0)
        var isCheckedByDefault = Model.PadrCamp.HasValue && Model.PadrCamp.Value == 1;
        <div class="@colClass mb-3">
            <div class="form-check pt-4">
                <input type="hidden" name="@fieldName" value="0" />
                <input type="checkbox"
                       class="form-check-input"
                       id="@fieldId"
                       name="@fieldName"
                       value="1"
                       title="@hint"
                       @(isCheckedByDefault ? "checked" : "")
                       @(isDisabled ? "disabled" : "") />
                @if (hasLabel)
                {
                    <label for="@fieldId" class="form-check-label">
                        @label
                    </label>
                }
            </div>
        </div>
        break;

    case ComponentType.ComboBox:
        // C - ComboBox com valores fixos (VareCamp)
        // Suporta formato "codigo=descricao" ou apenas "descricao"
        // Quando não há código explícito, usa o índice (0, 1, 2, ...) como valor
        // porque no Delphi o ItemIndex é salvo quando a coluna é int
        <div class="@colClass mb-3">
            @if (hasLabel)
            {
                <label for="@fieldId" class="form-label">
                    @label
                    @if (isRequired)
                    {
                        <span class="text-danger">*</span>
                    }
                </label>
            }
            <select class="form-select"
                    id="@fieldId"
                    name="@fieldName"
                    title="@hint"
                    @(isRequired ? "required" : "")
                    @(isDisabled ? "disabled" : "")>
                <option value="">Selecione...</option>
                @if (!string.IsNullOrEmpty(Model.VareCamp))
                {
                    var options = Model.VareCamp.Split(new[] { '|', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
                    var index = 0;
                    foreach (var opt in options)
                    {
                        var trimmed = opt.Trim();
                        // Formato "codigo=descricao" - usa o código explícito
                        // Caso contrário, usa o índice como valor (padrão Delphi para colunas int)
                        var parts = trimmed.Split('=', 2);
                        var optValue = parts.Length > 1 ? parts[0].Trim() : index.ToString();
                        var optDisplay = parts.Length > 1 ? parts[1].Trim() : trimmed;
                        <option value="@optValue">@optDisplay</option>
                        index++;
                    }
                }
            </select>
        </div>
        break;

    case ComponentType.LookupCombo:
        // T, IT - LookupCombo com SQL_CAMP
        // T = ligado ao banco, IT = informativo (sem persistência)
        // Na POC não há persistência, então ambos são tratados igualmente
        <div class="@colClass mb-3">
            @if (hasLabel)
            {
                <label for="@fieldId" class="form-label">
                    @label
                    @if (isRequired)
                    {
                        <span class="text-danger">*</span>
                    }
                </label>
            }
            <select class="form-select"
                    id="@fieldId"
                    name="@fieldName"
                    title="@hint"
                    @(isRequired ? "required" : "")
                    @(isDisabled ? "disabled" : "")>
                <option value="">Selecione...</option>
                @if (Model.LookupOptions != null && Model.LookupOptions.Count > 0)
                {
                    foreach (var opt in Model.LookupOptions)
                    {
                        <option value="@opt.Key">@opt.Value</option>
                    }
                }
                else if (!string.IsNullOrEmpty(Model.VareCamp))
                {
                    // Fallback para VareCamp se LookupOptions não foi carregado
                    // Usa índice como valor quando não há código explícito
                    var fallbackOptions = Model.VareCamp.Split(new[] { '|', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
                    var fbIndex = 0;
                    foreach (var opt in fallbackOptions)
                    {
                        var trimmed = opt.Trim();
                        var parts = trimmed.Split('=', 2);
                        var optValue = parts.Length > 1 ? parts[0].Trim() : fbIndex.ToString();
                        var optDisplay = parts.Length > 1 ? parts[1].Trim() : trimmed;
                        <option value="@optValue">@optDisplay</option>
                        fbIndex++;
                    }
                }
            </select>
        </div>
        break;

    case ComponentType.TextArea:
        // M, BM - TextArea/Memo
        var rows = Model.AltuCamp > 50 ? Model.AltuCamp / 25 : 3;
        <div class="col-12 mb-3">
            @if (hasLabel)
            {
                <label for="@fieldId" class="form-label">
                    @label
                    @if (isRequired)
                    {
                        <span class="text-danger">*</span>
                    }
                </label>
            }
            <textarea class="form-control"
                      id="@fieldId"
                      name="@fieldName"
                      title="@hint"
                      placeholder="@hint"
                      rows="@rows"
                      @(isRequired ? "required" : "")
                      @(isDisabled ? "disabled" : "")></textarea>
        </div>
        break;

    case ComponentType.Button:
        // BTN - Botão
        <div class="@colClass mb-3 d-flex align-items-end">
            <button type="button"
                    class="btn btn-secondary"
                    id="@fieldId"
                    title="@hint"
                    @(isDisabled ? "disabled" : "")>
                @label
            </button>
        </div>
        break;

    case ComponentType.DataGrid:
        // DBG - Grid (placeholder)
        <div class="col-12 mb-3">
            <div class="field-grid border rounded p-3 bg-light">
                <small class="text-muted">[Grid: @fieldName - @label]</small>
            </div>
        </div>
        break;

    case ComponentType.Bevel:
        // BVL - Não renderiza aqui, já é tratado no Render.cshtml
        break;

    case ComponentType.Hidden:
        // DEPOSHOW, ATUAGRID - Componentes internos, não renderiza
        break;

    default:
        // Fallback para input text
        <div class="@colClass mb-3">
            <label for="@fieldId" class="form-label">@label</label>
            <input type="text"
                   class="form-control"
                   id="@fieldId"
                   name="@fieldName"
                   title="@hint"
                   @(isDisabled ? "disabled" : "") />
        </div>
        break;
}
